<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>4SP - DASHBOARD</title>
  <link rel="stylesheet" href="../css/style.css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
  <script src="../panic-key.js"></script>
  <script src="../ban-enforcer.js"></script>
  <script src="../url-changer.js"></script>

  <style>
    /* --- START: Legal Disclaimer Popup Styles --- */
    #legal-disclaimer-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.85);
        backdrop-filter: blur(5px);
        z-index: 20000;
        display: flex;
        justify-content: center;
        align-items: center;
        visibility: hidden;
        opacity: 0;
        transition: opacity 0.3s ease, visibility 0.3s ease;
    }
    #legal-disclaimer-overlay.visible {
        visibility: visible;
        opacity: 1;
    }
    .disclaimer-modal {
        background-color: #fff;
        color: #333;
        padding: 30px;
        border-radius: 16px;
        width: 90%;
        max-width: 650px;
        box-shadow: 0 10px 40px rgba(0,0,0,0.2);
        display: flex;
        flex-direction: column;
    }
    .disclaimer-modal h2 {
        font-family: 'PrimaryFont', sans-serif;
        text-align: center;
        color: #6720bd;
        margin-top: 0;
        margin-bottom: 15px;
    }
    .disclaimer-text {
        max-height: 50vh;
        overflow-y: auto;
        border-top: 1px solid #eee;
        border-bottom: 1px solid #eee;
        padding: 15px;
        margin-bottom: 20px;
        font-size: 0.9em;
        line-height: 1.6;
    }
    .disclaimer-text h3 {
        font-family: 'PrimaryFont', sans-serif;
        font-size: 1.2em;
        color: #333;
        margin-top: 15px;
    }
    .disclaimer-text ul {
        list-style-type: disc;
        padding-left: 20px;
    }
    .disclaimer-buttons {
        display: flex;
        justify-content: flex-end;
        gap: 15px;
    }
    .disclaimer-buttons button {
        padding: 10px 25px;
        border-radius: 8px;
        border: none;
        font-family: 'PrimaryFont', sans-serif;
        font-weight: bold;
        cursor: pointer;
        transition: transform 0.2s ease;
    }
    .disclaimer-buttons button:hover {
        transform: translateY(-2px);
    }
    #disagree-btn {
        background-color: #6c757d;
        color: white;
    }
    #agree-btn {
        background-color: #6720bd;
        color: white;
    }
    /* --- END: Legal Disclaimer Popup Styles --- */

    /* --- Dashboard Layout --- */
    body.dashboard-page { display: flex; flex-direction: column; min-height: 100vh; margin: 0; font-family: 'PrimaryFont', sans-serif; }
    .dashboard-container { display: flex; flex: 1; }

    /* --- Sidebar --- */
    .sidebar { width: 200px; background: linear-gradient(180deg, #333 0%, #2a2a2a 100%); color: #fff; padding: 20px 10px; display: flex; flex-direction: column; border-right: 1px solid #444; transition: width 0.5s ease-in-out; position: relative; box-shadow: 2px 0 10px rgba(0,0,0,0.1); }
    .sidebar.collapsed { width: 85px; }
    #toggleSidebar { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); background: none; border: none; color: #fff; font-size: 1.2em; cursor: pointer; padding: 4px; transition: transform 0.5s ease-in-out; }
    .sidebar.collapsed #toggleSidebar { transform: translateX(-50%) rotate(180deg); }
    .sidebar nav ul { list-style: none; padding: 0; margin: 60px 0 0; }
    .sidebar nav li { margin-bottom: 10px; }
    .sidebar nav a { display: flex; align-items: center; padding: 12px 15px; color: #fff; text-decoration: none; border-radius: 8px; transition: all 0.3s ease; font-family: 'PrimaryFont', sans-serif; text-transform: uppercase; }
    .sidebar nav a.active, .sidebar nav a:hover { background: linear-gradient(135deg, #6720bd 0%, #8a2be2 100%); transform: translateX(5px); }
    .sidebar nav a .icon { font-size: 1.2em; width: 24px; text-align: center; }
    .sidebar nav a .label { margin-left: 10px; white-space: nowrap; opacity: 1; visibility: visible; transition: opacity 0.2s ease-in-out; transition-delay: 0.4s; }
    .sidebar.collapsed nav a .label { opacity: 0; visibility: hidden; transition-delay: 0s; }

    /* ... (rest of your existing styles are unchanged) ... */
  </style>
</head>
<body class="dashboard-page">

<div id="legal-disclaimer-overlay">
    <div class="disclaimer-modal">
        <h2>Terms of Service Update</h2>
        <div class="disclaimer-text">
            <p>By clicking "Agree," you confirm you understand and accept the following key points:</p>
            <ul>
                <li>You acknowledge that some games provided contain <strong>violence</strong> and are for entertainment purposes only.</li>
                <li>You are responsible for any <strong>downloadable apps</strong> you choose to run. For the Notes app, you are solely responsible for the password to your <strong>encrypted notes</strong>.</li>
                <li>This project accepts <strong>voluntary, non-refundable donations</strong> to cover operational costs.</li>
                <li>You are fully and absolutely responsible for your actions while using this service.</li>
            </ul>
            <p><em>For more information, <a href="../legal.html" target="_blank" style="color: #6720bd; text-decoration: underline;">click here</a>.</em></p>
        </div>
        <div class="disclaimer-buttons">
            <button id="disagree-btn">Disagree</button>
            <button id="agree-btn">Agree</button>
        </div>
    </div>
</div>

  <header class="main-header light-bg">
    <div class="container">
      <div class="logo"> <a href="../index.html"> <img src="../images/logo-dark.png" alt="4SP Logo" /> </a> </div>
      <div class="auth-buttons"> <button class="btn btn-login" onclick="window.location.href='../index.html'">HOME</button> <button id="logoutBtn" class="btn btn-login">LOG OUT</button> </div>
    </div>
  </header>
  <div class="dashboard-container">
    <aside class="sidebar" id="sidebar">
      </aside>
    <main class="main-content">
      </main>
  </div>
  <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-firestore-compat.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
  <script src="../firebase-config.js"></script>
  <script>
    // --- THIS IS THE FULL, CORRECTED AND CONSOLIDATED SCRIPT ---

// --- GLOBALS AND UTILITIES ---
const getStorageKey = (key) => firebase.auth().currentUser ? `4sp_${key}_${firebase.auth().currentUser.uid}` : `4sp_${key}_guest`;
const WMO_CODES={0:{d:"Clear sky",i:"‚òÄÔ∏è"},1:{d:"Mainly clear",i:"üå§Ô∏è"},2:{d:"Partly cloudy",i:"üå•Ô∏è"},3:{d:"Overcast",i:"‚òÅÔ∏è"},45:{d:"Fog",i:"üå´Ô∏è"},48:{d:"Rime fog",i:"üå´Ô∏è"},51:{d:"Light drizzle",i:"üå¶Ô∏è"},53:{d:"Drizzle",i:"üå¶Ô∏è"},55:{d:"Dense drizzle",i:"üåßÔ∏è"},56:{d:"Light freezing drizzle",i:"üå®Ô∏è"},57:{d:"Dense freezing drizzle",i:"üå®Ô∏è"},61:{d:"Slight rain",i:"üåßÔ∏è"},63:{d:"Rain",i:"üåßÔ∏è"},65:{d:"Heavy rain",i:"üåßÔ∏è"},66:{d:"Light freezing rain",i:"üå®Ô∏è"},67:{d:"Heavy freezing rain",i:"üå®Ô∏è"},71:{d:"Slight snow",i:"‚ùÑÔ∏è"},73:{d:"Snow",i:"‚ùÑÔ∏è"},75:{d:"Heavy snow",i:"‚ùÑÔ∏è"},77:{d:"Snow grains",i:"‚ùÑÔ∏è"},80:{d:"Slight showers",i:"üå¶Ô∏è"},81:{d:"Showers",i:"üå¶Ô∏è"},82:{d:"Violent showers",i:"‚õàÔ∏è"},85:{d:"Slight snow showers",i:"üå®Ô∏è"},86:{d:"Heavy snow showers",i:"üå®Ô∏è"},95:{d:"Thunderstorm",i:"‚õàÔ∏è"},96:{d:"Thunderstorm, slight hail",i:"‚õàÔ∏è"},99:{d:"Thunderstorm, heavy hail",i:"‚õàÔ∏è"}};

// --- DOM Elements ---
const dashboardGrid = document.getElementById('dashboardGrid');
const editModeHint = document.getElementById('edit-mode-hint');

// --- Layout Globals ---
const dashboardLayoutStorageKey = '4sp_dashboardLayout_v2_super';
let selectedWidgetId = null;
const defaultDashboardLayout = ['time_weather_super_widget', 'stopwatch_widget', 'timer_widget', 'quick_actions_widget'];
const pageSuggestions = [ { name: 'Dashboard', url: 'dashboard.html' }, { name: 'Games', url: 'games.html' }, { name: 'Soundboard', url: 'soundboard.html' }, { name: 'Notes', url: 'notes.html' }, { name: 'Countdowns', url: 'countdowns.html' }, { name: 'Requests', url: 'requests.html' }, { name: 'Apps', url: 'apps.html' }, { name: 'Weather', url: 'weather.html' }, { name: 'Settings', url: 'settings.html' }];

// --- Quick Actions / Shortcuts Globals ---
const defaultQuickActions = [
    { icon: "üéì", text: "Classroom", type: "url", value: "https://classroom.google.com/" },
    { icon: "üìù", text: "Notes", type: "page", value: "notes.html" },
    { icon: "üóìÔ∏è", text: "Countdowns", type: "page", value: "countdowns.html" },
    { icon: "üéµ", text: "Requests", type: "page", value: "requests.html" }
];
let currentQuickActions = [...defaultQuickActions];

// --- Settings Globals ---
const defaultWeatherSettings = { dataSource: 'open-meteo', location: { label: 'New York, NY', latitude: 40.71, longitude: -74.01 }, units: 'imperial', showWeatherInFullscreen: false };
const defaultGeneralSettings = { titleDisplay: 'none' };
let weatherSettings = { ...defaultWeatherSettings };
let generalSettings = { ...defaultGeneralSettings };
let userCoords = null, userCountry = null, fullWeatherData = null;

// --- SETTINGS LOGIC ---
function saveWeatherSettings() { localStorage.setItem(getStorageKey('weatherWidgetSettings'), JSON.stringify(weatherSettings)); }
function loadWeatherSettings() { const s = localStorage.getItem(getStorageKey('weatherWidgetSettings')); if (s) { try { const loaded = JSON.parse(s); weatherSettings = { ...defaultWeatherSettings, ...loaded }; } catch(e) { console.error("Failed to parse weather settings", e); } } }
function saveGeneralSettings() { localStorage.setItem(getStorageKey('generalSettings_v1'), JSON.stringify(generalSettings)); }
function loadGeneralSettings() { const s = localStorage.getItem(getStorageKey('generalSettings_v1')); if (s) { try { const loaded = JSON.parse(s); generalSettings = { ...defaultGeneralSettings, ...loaded }; } catch(e) { console.error("Failed to parse general settings", e); } } }

// --- WEATHER LOGIC ---
async function determineUserCountry() { try { const r = await fetch('https://ipapi.co/json/'); if (!r.ok) return; const d = await r.json(); userCountry = d.country_code?.toUpperCase(); } catch (e) { console.warn("Could not determine user country from IP.", e); } }
function mapNWSKeywordsToWMO(f) { if (!f) return 0; f=f.toLowerCase(); if (f.includes("thunderstorm")||f.includes("t-storm")) return 95; if (f.includes("snow")||f.includes("flurr")) return 73; if (f.includes("rain")||f.includes("shower")) return 63; if (f.includes("drizzle")) return 53; if (f.includes("fog")) return 45; if (f.includes("overcast")||f.includes("cloudy")) return 3; if (f.includes("partly cloudy")||f.includes("mostly cloudy")) return 2; if (f.includes("mostly clear")||f.includes("partly sunny")) return 1; if (f.includes("sunny")||f.includes("clear")) return 0; return 0; }

function transformNWSData(daily, hourly) {
    const t = { latitude: weatherSettings.location.latitude, longitude: weatherSettings.location.longitude, utc_offset_seconds: new Date().getTimezoneOffset() * -60, timezone: Intl.DateTimeFormat().resolvedOptions().timeZone, current: {}, hourly: {}, daily: {} };
    const now = hourly.periods[0];
    t.current = { time: now.startTime, temperature_2m: now.temperature, relative_humidity_2m: now.relativeHumidity.value, apparent_temperature: now.temperature, weather_code: mapNWSKeywordsToWMO(now.shortForecast), wind_speed_10m: parseInt(now.windSpeed.split(' ')[0],10) };
    const dailyPeriods = []; for (let i = 0; i < daily.periods.length; i++) { if (daily.periods[i].isDaytime) { const night = (daily.periods[i+1] && !daily.periods[i+1].isDaytime) ? daily.periods[i+1] : daily.periods[i]; dailyPeriods.push({ day: daily.periods[i], night }); } }
    t.daily = { time: dailyPeriods.map(p => p.day.startTime.split('T')[0]), weather_code: dailyPeriods.map(p => mapNWSKeywordsToWMO(p.day.shortForecast)), temperature_2m_max: dailyPeriods.map(p => p.day.temperature), temperature_2m_min: dailyPeriods.map(p => p.night.temperature), precipitation_sum: dailyPeriods.map(()=>null), precipitation_probability_max: dailyPeriods.map(p=>Math.max(p.day.probabilityOfPrecipitation.value||0, p.night.probabilityOfPrecipitation.value||0)), wind_speed_10m_max: dailyPeriods.map(p=>parseInt(p.day.windSpeed.split(' ')[0],10)), sunrise: dailyPeriods.map(()=>null), sunset: dailyPeriods.map(()=>null), daylight_duration: dailyPeriods.map(()=>null), wind_direction_10m_dominant: dailyPeriods.map(()=>null), uv_index_max: dailyPeriods.map(()=>null), relative_humidity_2m_mean: dailyPeriods.map(() => null) };
    return t;
}

const fetchWeather = async () => {
    const widget = document.querySelector('.dashboard-card[data-template-id="time_weather_super_widget"]');
    const refreshBtn = widget?.querySelector('.weather-refresh-btn');
    const refreshImg = refreshBtn?.querySelector('img');
    if (refreshBtn) { refreshBtn.disabled = true; if(refreshImg) refreshImg.classList.add('refreshing'); }
    try {
        if (weatherSettings.dataSource === 'nws') {
            const { latitude, longitude } = weatherSettings.location; const r = await fetch(`https://api.weather.gov/points/${latitude},${longitude}`); if (!r.ok) throw new Error("Outside NWS (USA) coverage."); const d = await r.json();
            const [forecastRes, hourlyRes] = await Promise.all([fetch(d.properties.forecast), fetch(d.properties.forecastHourly)]); if (!forecastRes.ok || !hourlyRes.ok) throw new Error("Failed to get NWS forecast details.");
            const [dailyData, hourlyData] = await Promise.all([forecastRes.json(), hourlyRes.json()]); fullWeatherData = transformNWSData(dailyData.properties, hourlyData.properties);
        } else {
            const {units,location}=weatherSettings; const p=new URLSearchParams({current:"temperature_2m,relative_humidity_2m,apparent_temperature,weather_code,wind_speed_10m",daily:"weather_code,temperature_2m_max,temperature_2m_min,precipitation_sum,precipitation_probability_max,wind_speed_10m_max,sunrise,sunset,daylight_duration,wind_direction_10m_dominant,uv_index_max,relative_humidity_2m_mean",timezone:"auto",forecast_days:7,temperature_unit:units==='metric'?'celsius':'fahrenheit',wind_speed_unit:units==='metric'?'kmh':'mph'});
            const r = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${location.latitude}&longitude=${location.longitude}&${p}`); if (!r.ok) throw new Error(`API Error: ${r.status}`); fullWeatherData = await r.json();
        }
        if (window.renderWeatherInDashboard) window.renderWeatherInDashboard(fullWeatherData);
    } catch (error) { if (window.renderWeatherErrorInDashboard) window.renderWeatherErrorInDashboard(error.message);
    } finally { if (refreshBtn) { refreshBtn.disabled = false; if(refreshImg) refreshImg.classList.remove('refreshing'); } }
};

// --- FORECAST MODAL & ADVICE LOGIC ---
function formatDaylightDuration(s) { if (s == null) return 'N/A'; const h=Math.floor(s/3600); const m=Math.floor((s%3600)/60); return `${h}h ${m}m`; }
function degreesToCardinal(d) { if (d==null) return 'N/A'; const v=Math.floor((d/22.5)+0.5); const a=["N", "NNE", "NE", "ENE", "E", "ESE", "SE", "SSE", "S", "SSW", "SW", "WSW", "W", "WNW", "NW", "NNW"]; return a[(v % 16)]; }
function generateWeatherAdvice(dayData) {
    const advice = new Set(); const { tempMax, tempMin, weatherCode, precipSum, precipProb, windSpeedMax, humidity, uvIndexMax } = dayData; const units = weatherSettings.units;
    const tempMaxC = units === 'imperial' ? (tempMax - 32) * 5 / 9 : tempMax; const tempMinC = units === 'imperial' ? (tempMin - 32) * 5 / 9 : tempMin; const windSpeedMph = units === 'metric' ? windSpeedMax * 0.621371 : windSpeedMax;
    if (tempMaxC >= 32) advice.add("Extreme heat expected. Stay hydrated and avoid strenuous activity."); else if (tempMaxC >= 25) advice.add("It's going to be hot. Wear light clothing."); else if (tempMinC <= 0) advice.add("Freezing temperatures overnight. Watch for icy patches."); else if (tempMaxC <= 5) advice.add("It's quite cold. Bundle up with a thick coat.");
    if (Math.abs(tempMax - tempMin) > (units === 'imperial' ? 25 : 14)) advice.add("Large temperature swing today. Dressing in layers is a good idea.");
    if ((precipSum != null && precipSum > 0.1) || (precipProb != null && precipProb > 40)) { if ([61, 63, 65, 80, 81, 82].includes(weatherCode)) advice.add("Rain is likely. Don't forget an umbrella."); else if ([71, 73, 75, 85, 86].includes(weatherCode)) advice.add("Snow is expected! Wear a warm, waterproof coat."); else if ([95, 96, 99].includes(weatherCode)) advice.add("Thunderstorms are possible. Stay indoors if you hear thunder."); else advice.add("There's a chance of precipitation."); }
    if (windSpeedMph >= 15) advice.add("It could be quite windy. A windbreaker is recommended."); if (humidity != null && tempMaxC >= 28 && humidity >= 60) advice.add("High heat and humidity will make it feel very muggy."); if ([45, 48].includes(weatherCode)) advice.add("Foggy conditions are expected. Be extra cautious if you're driving.");
    if (uvIndexMax != null) { if (uvIndexMax >= 8) advice.add("UV index is very high. Seek shade and use strong sunscreen."); else if (uvIndexMax >= 6) advice.add("High UV index today. Sunscreen is recommended."); }
    if (advice.size === 0) { if ([0, 1].includes(weatherCode)) return "<p>Looks like a beautiful day. Perfect for outdoor activities!</p>"; if (tempMaxC > 18 && tempMaxC < 24 && (!precipProb || precipProb < 20)) return "<p>Conditions look pleasant and mild. A great day to be outside!</p>"; return "<p>Enjoy your day! Check the details above for a full forecast.</p>"; }
    return '<ul>' + [...advice].map(item => `<li>${item}</li>`).join('') + '</ul>';
}
function openForecastModal(dayData) {
    const tempS = weatherSettings.units === 'metric' ? '¬∞C' : '¬∞F'; const speedS = weatherSettings.units === 'metric' ? 'km/h' : 'mph';
    const utcDate = new Date(dayData.dateStr + 'T12:00:00Z');
    document.getElementById('modalDayDate').textContent = utcDate.toLocaleDateString(undefined, { weekday: 'long' });
    document.getElementById('modalFullDateSubtitle').textContent = utcDate.toLocaleDateString(undefined, { year: 'numeric', month: 'long', day: 'numeric' });
    const codeInfo = WMO_CODES[dayData.weatherCode] || { description: "Unknown", icon: "‚ùì" };
    document.getElementById('modalWeatherIcon').textContent = codeInfo.icon; document.getElementById('modalWeatherDesc').textContent = codeInfo.description;
    document.getElementById('modalMaxTemp').textContent = `${Math.round(dayData.tempMax)}${tempS}`; document.getElementById('modalMinTemp').textContent = `${Math.round(dayData.tempMin)}${tempS}`;
    document.getElementById('modalPrecipSum').textContent = `${dayData.precipSum != null ? dayData.precipSum : '--'} ${weatherSettings.units === 'metric' ? 'mm' : 'in'}`;
    document.getElementById('modalPrecipProb').textContent = `${dayData.precipProb != null ? dayData.precipProb : '--'}%`;
    document.getElementById('modalWindSpeed').textContent = `${dayData.windSpeedMax != null ? Math.round(dayData.windSpeedMax) : '--'} ${speedS}`;
    document.getElementById('modalWindDirection').textContent = degreesToCardinal(dayData.windDirection);
    document.getElementById('modalDaylightDuration').textContent = formatDaylightDuration(dayData.daylightDuration);
    document.getElementById('modalSunriseTime').textContent = dayData.sunrise ? new Date(dayData.sunrise).toLocaleTimeString([],{hour:'2-digit', minute:'2-digit'}) : 'N/A';
    document.getElementById('modalSunsetTime').textContent = dayData.sunset ? new Date(dayData.sunset).toLocaleTimeString([],{hour:'2-digit', minute:'2-digit'}) : 'N/A';
    document.getElementById('modalFeelsLike').textContent = `${dayData.feelsLike != null ? Math.round(dayData.feelsLike) : '--'}${tempS}`;
    document.getElementById('modalHumidity').textContent = `${dayData.humidity != null ? dayData.humidity : '--'}%`;
    document.getElementById('modalDailyAdvice').innerHTML = generateWeatherAdvice(dayData);
    document.getElementById('forecastDetailModal').classList.add('modal-open');
}

// --- FULLSCREEN CLOCK & TAB TITLE LOGIC ---
const clockFsOverlay=document.getElementById('clock-fullscreen-overlay'),clockFsTime=document.getElementById('clock-fs-main-time'),clockFsDate=document.getElementById('clock-fs-main-date'),clockFsCountdownName=document.getElementById('clock-fs-countdown-name'),clockFsCountdownTimer=document.getElementById('clock-fs-countdown-timer');
let clockFsTimeout, clockFsCountdownTimeout, inactivityTimer, titleUpdateInterval, originalTitle = document.title;
let activeGroupId = null; // For countdown groups

function resetInactivityTimer() {
    if (document.getElementById('customGradientModal')?.classList.contains('modal-open')) {
        clearTimeout(inactivityTimer);
        return;
    }
    clearTimeout(inactivityTimer);
    const controls = document.querySelectorAll('.clock-fs-controls, .clock-fs-right-controls');
    const weatherDisplay = document.getElementById('fullscreen-weather-display');
    clockFsOverlay.classList.remove('inactive-cursor');
    controls.forEach(c => c.classList.remove('controls-hidden'));
    if (weatherDisplay.style.display !== 'none') weatherDisplay.style.right = '80px';
    inactivityTimer = setTimeout(() => {
        clockFsOverlay.classList.add('inactive-cursor');
        controls.forEach(c => c.classList.add('controls-hidden'));
        if (weatherDisplay.style.display !== 'none') weatherDisplay.style.right = '20px';
    }, 3000);
}

function openClockFullscreen(){
    const savedColor = localStorage.getItem(getStorageKey('clockFsColor'));
    if (savedColor) clockFsOverlay.style.background = savedColor;
    clockFsOverlay.classList.add('active');
    updateFullscreenClock();
    clockFsOverlay.requestFullscreen().catch(err=>{console.error("Fullscreen request failed:",err);closeClockFullscreen()});
    
    populateAndInitCountdownDropdown('fullscreen-countdown-select-wrapper', setActiveDisplay);
    const savedId = localStorage.getItem(getStorageKey('selectedDashboardCountdownId'));
    setActiveDisplay(savedId);

    updateFullscreenWeatherDisplay();
    clockFsOverlay.addEventListener('mousemove', resetInactivityTimer);
    resetInactivityTimer();
}

function closeClockFullscreen(){
    clockFsOverlay.classList.remove('active');
    clearTimeout(clockFsTimeout);
    clearTimeout(clockFsCountdownTimeout);
    clearTimeout(inactivityTimer);
    clockFsOverlay.removeEventListener('mousemove', resetInactivityTimer);
    clockFsOverlay.classList.remove('inactive-cursor');
    document.querySelectorAll('.clock-fs-controls, .clock-fs-right-controls').forEach(c => c.classList.remove('controls-hidden'));
    if(window.updateDashboardCountdownDisplay) window.updateDashboardCountdownDisplay();
}

document.addEventListener('fullscreenchange', ()=>{if(!document.fullscreenElement)closeClockFullscreen()});

function updateBrowserTabTitle() {
    switch (generalSettings.titleDisplay) {
        case 'time':
            document.title = new Date().toLocaleTimeString();
            break;
        case 'none':
        default:
            if (document.title !== originalTitle) {
                document.title = originalTitle;
            }
            break;
    }
}

function updateFullscreenClock(){
    const n=new Date();
    clockFsTime.textContent = n.toLocaleTimeString([], { hour12: true, hour: 'numeric', minute: '2-digit', second: '2-digit' });
    clockFsDate.textContent=n.toLocaleDateString(undefined,{weekday:'long',year:'numeric',month:'long',day:'numeric'});
    
    const msUntilNextSecond = 1000 - n.getMilliseconds();
    clockFsTimeout = setTimeout(updateFullscreenClock, msUntilNextSecond);
}

function updateFullscreenWeatherDisplay() {
    const container = document.getElementById('fullscreen-weather-display');
    if (weatherSettings.showWeatherInFullscreen && fullWeatherData) {
        const { current } = fullWeatherData;
        const codeInfo = WMO_CODES[current.weather_code] || { d: '', i: '‚ùì' };
        const tempSuffix = weatherSettings.units === 'metric' ? '¬∞C' : '¬∞F';
        container.innerHTML = `<div class="icon">${codeInfo.i}</div><div><div class="temp">${Math.round(current.temperature_2m)}${tempSuffix}</div><div class="condition">${codeInfo.d}</div></div>`;
        container.style.display = 'flex';
    } else {
        container.style.display = 'none';
    }
}

// --- COUNTDOWN LOGIC (including GROUPS) ---
function calculateNextOccurrence(countdown) {
    if (!countdown.repeat) return new Date(countdown.targetTimestamp);
    let lastTarget = new Date(countdown.targetTimestamp);
    let now = new Date();
    if (lastTarget > now) return lastTarget;
    let nextTarget = new Date(lastTarget);
    if (countdown.repeat.type === 'daily') {
        const diffDays = Math.ceil((now - nextTarget) / (1000 * 60 * 60 * 24));
        nextTarget.setDate(nextTarget.getDate() + diffDays);
        if (nextTarget <= now) nextTarget.setDate(nextTarget.getDate() + 1);
    } else if (countdown.repeat.type === 'weekly' && countdown.repeat.days?.length > 0) {
        const sortedDays = countdown.repeat.days.map(d => parseInt(d)).sort((a,b) => a - b);
        while (nextTarget <= now) {
            let currentDay = nextTarget.getDay();
            let nextDayInCycle = sortedDays.find(d => d > currentDay);
            if (nextDayInCycle !== undefined) {
                nextTarget.setDate(nextTarget.getDate() + (nextDayInCycle - currentDay));
            } else {
                nextTarget.setDate(nextTarget.getDate() + (7 - currentDay + sortedDays[0]));
            }
        }
    }
    return nextTarget;
}

function formatCountdown(targetDate) {
    const end = new Date(targetDate);
    const now = new Date();
    if (end <= now) { return "üéâ Finished!"; }

    let years = end.getFullYear() - now.getFullYear();
    let months = end.getMonth() - now.getMonth();
    let days = end.getDate() - now.getDate();
    let hours = end.getHours() - now.getHours();
    let minutes = end.getMinutes() - now.getMinutes();
    let seconds = end.getSeconds() - now.getSeconds();

    if (seconds < 0) { minutes--; seconds += 60; }
    if (minutes < 0) { hours--; minutes += 60; }
    if (hours < 0) { days--; hours += 24; }
    if (days < 0) {
        months--;
        const lastDayOfPrevMonth = new Date(end.getFullYear(), end.getMonth(), 0).getDate();
        days += lastDayOfPrevMonth;
    }
    if (months < 0) { years--; months += 12; }
    
    const units = [
        {v: years, l:'yrs'},
        {v: months, l:'mths'},
        {v: days, l:'days'},
        {v: hours, l:'hrs'},
        {v: minutes, l:'mins'},
        {v: seconds, l:'secs'}
    ];
    
    const visibleUnits = units.filter((unit, idx) => units.slice(0, idx).reduce((acc, p) => acc + p.v, 0) + unit.v > 0);
    return visibleUnits.map(unit => `<span class="time-unit">${unit.v}<span class="time-label">${unit.l}</span></span>`).join('') || `<span class="time-unit">0<span class="time-label">secs</span></span>`;
}

function playNextInGroup(groupId) {
    activeGroupId = groupId;
    const countdowns = JSON.parse(localStorage.getItem(getStorageKey('countdowns')) || '[]');
    const groups = JSON.parse(localStorage.getItem(getStorageKey('countdownGroups')) || '[]');
    const group = groups.find(g => g.id === groupId);
    if (!group) { console.error("Group not found"); return; }

    const now = new Date();
    const nextCountdown = group.countdownIds
        .map(id => countdowns.find(cd => cd.id === id))
        .filter(cd => cd && cd.repeat)
        .map(cd => ({ ...cd, nextOccurrence: calculateNextOccurrence(cd) }))
        .filter(cd => cd.nextOccurrence > now)
        .sort((a, b) => a.nextOccurrence - b.nextOccurrence)[0];
    
    if (nextCountdown) { displaySingleCountdown(nextCountdown); } 
    else {
        clockFsCountdownName.textContent = `${group.name} Finished`;
        clockFsCountdownTimer.innerHTML = '';
    }
}

function displaySingleCountdown(countdown) {
    if (!countdown) {
         clockFsCountdownName.textContent = ''; clockFsCountdownTimer.innerHTML = ''; return;
    }
    clockFsCountdownName.textContent = countdown.name;
    const tick = () => {
        const nextOccurrence = calculateNextOccurrence(countdown);
        const formattedTime = formatCountdown(nextOccurrence);
        clockFsCountdownTimer.innerHTML = formattedTime;

        if (formattedTime.includes("Finished")) {
            clearTimeout(clockFsCountdownTimeout);
            if (activeGroupId) { setTimeout(() => playNextInGroup(activeGroupId), 1000); }
            return;
        }
        const msUntilNextSecond = 1000 - new Date().getMilliseconds();
        clockFsCountdownTimeout = setTimeout(tick, msUntilNextSecond);
    };
    tick();
}

function setActiveDisplay(id) {
    clearTimeout(clockFsCountdownTimeout);
    localStorage.setItem(getStorageKey('selectedDashboardCountdownId'), id || '');
    
    if (!id) {
        activeGroupId = null;
        clockFsCountdownName.textContent = '';
        clockFsCountdownTimer.innerHTML = '';
        return;
    }

    if (id.startsWith('group_')) {
        playNextInGroup(id.replace('group_', ''));
    } else {
        activeGroupId = null;
        const countdowns = JSON.parse(localStorage.getItem(getStorageKey('countdowns')) || '[]');
        const countdown = countdowns.find(cd => cd.id === id);
        displaySingleCountdown(countdown);
    }
}

function populateAndInitCountdownDropdown(wrapperId, callback) {
    const wrapper = document.getElementById(wrapperId);
    if (!wrapper) return;
    const customOptions = wrapper.querySelector('.custom-options');
    const customSelectTrigger = wrapper.querySelector('.custom-select-trigger span');

    const countdowns = JSON.parse(localStorage.getItem(getStorageKey('countdowns')) || '[]');
    const groups = JSON.parse(localStorage.getItem(getStorageKey('countdownGroups')) || '[]');
    
    let optionsHTML = '<span class="custom-option" data-value="">-- None --</span>';
    const now = new Date();

    if (groups && groups.length > 0) {
        optionsHTML += '<div class="custom-optgroup">Groups</div>';
        groups.forEach(g => {
            optionsHTML += `<span class="custom-option" data-value="group_${g.id}">${g.name}</span>`;
        });
    }
    
    const upcomingCountdowns = countdowns.filter(cd => new Date(cd.targetTimestamp) > now || cd.repeat).sort((a, b) => new Date(a.targetTimestamp) - new Date(b.targetTimestamp));
    if (upcomingCountdowns.length > 0) {
        optionsHTML += '<div class="custom-optgroup">Countdowns</div>';
        upcomingCountdowns.forEach(cd => {
            optionsHTML += `<span class="custom-option" data-value="${cd.id}">${cd.name}</span>`;
        });
    }
    customOptions.innerHTML = optionsHTML;

    const savedId = localStorage.getItem(getStorageKey('selectedDashboardCountdownId')) || '';
    const selectedOption = customOptions.querySelector(`.custom-option[data-value="${savedId}"]`) || customOptions.querySelector('.custom-option[data-value=""]');
    
    if (selectedOption) {
        customOptions.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
        selectedOption.classList.add('selected');
        customSelectTrigger.textContent = selectedOption.textContent;
    }
    
    if (callback) {
        initializeCustomSelect(wrapper, callback);
    }
}

function populateAllCountdownDropdowns() {
    populateAndInitCountdownDropdown('overview-countdown-select-wrapper', (value) => {
        localStorage.setItem(getStorageKey('selectedDashboardCountdownId'), value);
        if(window.updateDashboardCountdownDisplay) window.updateDashboardCountdownDisplay();
    });
}

// --- WIDGET TEMPLATES & LOGIC ---
const availableCardTemplates = [
  {
    templateId: 'time_weather_super_widget', title: 'Overview', icon: 'üåê', type: 'full',
    onMount: async (cardElement) => {
      const timeEl = cardElement.querySelector('#clockTime');
      const dateEl = cardElement.querySelector('#clockDate');
      const dayOfYearEl = cardElement.querySelector('#clockDayOfYear');
      const weekNumEl = cardElement.querySelector('#clockWeekNum');
      const fullscreenBtn = cardElement.querySelector('.clock-fullscreen-btn');
      
      function updateClock() {
        const now = new Date();
        timeEl.textContent = now.toLocaleTimeString([], { hour12: true, hour: 'numeric', minute: '2-digit', second: '2-digit' });
        dateEl.textContent = now.toLocaleDateString(undefined, { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });
        const start = new Date(now.getFullYear(), 0, 0);
        const diff = (now - start) + ((start.getTimezoneOffset() - now.getTimezoneOffset()) * 60 * 1000);
        const oneDay = 1000 * 60 * 60 * 24;
        const dayOfYear = Math.floor(diff / oneDay);
        if (dayOfYearEl) dayOfYearEl.textContent = `Day: ${dayOfYear}`;
        const tempDate = new Date(now.valueOf());
        tempDate.setDate(tempDate.getDate() + 3 - (tempDate.getDay() + 6) % 7);
        const week1 = new Date(tempDate.getFullYear(), 0, 4);
        const weekNumber = 1 + Math.round(((tempDate.getTime() - week1.getTime()) / 86400000 - 3 + (week1.getDay() + 6) % 7) / 7);
        if (weekNumEl) weekNumEl.textContent = `Week: ${weekNumber}`;
      }
      updateClock(); setInterval(updateClock, 1000);
      if (fullscreenBtn) fullscreenBtn.addEventListener('click', openClockFullscreen);

      const countdownNameEl = cardElement.querySelector('.dashboard-countdown-display-name');
      const countdownTimerEl = cardElement.querySelector('.dashboard-countdown-display-timer');
      const countdownSectionEl = cardElement.querySelector('.dashboard-countdown-section');
      const additionalInfoEl = cardElement.querySelector('.additional-time-info');
      window.dashboardCountdownTimeout = null;

      function renderCountdownInDashboard(id) {
        clearTimeout(window.dashboardCountdownTimeout);
        if (!id) { countdownSectionEl.style.display = 'none'; additionalInfoEl.style.display = 'block'; return; }

        const countdowns = JSON.parse(localStorage.getItem(getStorageKey('countdowns')) || '[]');
        const groups = JSON.parse(localStorage.getItem(getStorageKey('countdownGroups')) || '[]');
        let displayCountdown;
        let displayName;

        if (id.startsWith('group_')) {
          const groupId = id.replace('group_', '');
          const group = groups.find(g => g.id === groupId);
          if (!group) { countdownSectionEl.style.display = 'none'; additionalInfoEl.style.display = 'block'; return; }
          displayName = group.name;
          const now = new Date();
          displayCountdown = group.countdownIds
            .map(cid => countdowns.find(cd => cd.id === cid))
            .filter(cd => cd && cd.repeat)
            .map(cd => ({...cd, nextOccurrence: calculateNextOccurrence(cd)}))
            .filter(cd => cd.nextOccurrence > now)
            .sort((a,b) => a.nextOccurrence - b.nextOccurrence)[0];
        } else {
          displayCountdown = countdowns.find(cd => cd.id === id);
          if (displayCountdown) displayName = displayCountdown.name;
        }
        
        if (!displayCountdown || new Date(displayCountdown.targetTimestamp) <= new Date() && !displayCountdown.repeat) {
          countdownSectionEl.style.display = 'none';
          additionalInfoEl.style.display = 'block';
          return;
        }
        
        countdownSectionEl.style.display = 'flex';
        additionalInfoEl.style.display = 'none';
        countdownNameEl.textContent = displayName;
        
        const tick = () => {
          const target = calculateNextOccurrence(displayCountdown);
          const formattedTime = formatCountdown(target);
          countdownTimerEl.innerHTML = formattedTime;
          if (formattedTime.includes("Finished")) {
            clearTimeout(window.dashboardCountdownTimeout);
            if (id.startsWith('group_')) { setTimeout(() => renderCountdownInDashboard(id), 1000); }
            return;
          }
          const msUntilNextSecond = 1000 - new Date().getMilliseconds();
          window.dashboardCountdownTimeout = setTimeout(tick, msUntilNextSecond);
        };
        tick();
      }

      window.updateDashboardCountdownDisplay = () => {
        const savedId = localStorage.getItem(getStorageKey('selectedDashboardCountdownId'));
        renderCountdownInDashboard(savedId);
      };
      window.updateDashboardCountdownDisplay();
      
      const refreshBtn = cardElement.querySelector('.weather-refresh-btn'), settingsBtn = cardElement.querySelector('.overview-settings-btn');
      window.renderWeatherErrorInDashboard = (message) => {
        const els = { c: cardElement.querySelector('.condition-large'), i: cardElement.querySelector('.weather-icon-large'), t: cardElement.querySelector('.temp-large'), f: cardElement.querySelector('.forecast-large') };
        if(els.c) els.c.textContent = message; if(els.i) els.i.textContent = '‚ö†Ô∏è'; if(els.t) els.t.textContent = '--¬∞'; if(els.f) els.f.innerHTML = `<p style="color:red;font-size:0.9em;">${message}</p>`;
      };
      window.renderWeatherInDashboard = (data) => {
        const {units, location} = weatherSettings; const tempS = units === 'metric' ? '¬∞C' : '¬∞F';
        const cw = data.current; const codeInfo = WMO_CODES[cw.weather_code] || {d: "Unknown", i: "‚ùì"};
        cardElement.querySelector('.temp-large').textContent = `${Math.round(cw.temperature_2m)}${tempS}`;
        cardElement.querySelector('.weather-icon-large').textContent = codeInfo.i;
        cardElement.querySelector('.condition-large').textContent = codeInfo.d;
        cardElement.querySelector('.feels-like-value').textContent = `${Math.round(cw.apparent_temperature)}${tempS}`;
        cardElement.querySelector('.humidity-value').textContent = `${cw.relative_humidity_2m}%`;
        cardElement.querySelector('.wind-value').textContent = `${Math.round(cw.wind_speed_10m)} ${units === 'metric' ? 'km/h' : 'mph'}`;
        cardElement.querySelector('.location-large').textContent = location.label;
        const forecastEl = cardElement.querySelector('.forecast-large'); forecastEl.innerHTML = '';
        if (data.daily?.time?.length > 0) {
          data.daily.time.forEach((dateStr, i) => {
            const dayCodeInfo = WMO_CODES[data.daily.weather_code[i]] || { i: "‚ùì" };
            const dayDiv = document.createElement('div'); dayDiv.className = 'forecast-day'; dayDiv.addEventListener('click', () => {
              openForecastModal({
                dateStr, feelsLike: cw.apparent_temperature, humidity: cw.relative_humidity_2m,
                weatherCode: data.daily.weather_code[i], tempMax: data.daily.temperature_2m_max[i], tempMin: data.daily.temperature_2m_min[i],
                precipSum: data.daily.precipitation_sum?.[i], precipProb: data.daily.precipitation_probability_max?.[i], windSpeedMax: data.daily.wind_speed_10m_max?.[i],
                sunrise: data.daily.sunrise?.[i], sunset: data.daily.sunset?.[i], daylightDuration: data.daily.daylight_duration?.[i], windDirection: data.daily.wind_direction_10m_dominant?.[i],
                uvIndexMax: data.daily.uv_index_max?.[i]
              });
            });
            const dayName = i === 0 ? "Today" : new Date(dateStr + 'T12:00:00Z').toLocaleDateString(undefined, { weekday: 'short', timeZone: 'UTC' });
            dayDiv.innerHTML = `<span class="day-name">${dayName}</span><span class="icon">${dayCodeInfo.i}</span><span class="temps">${Math.round(data.daily.temperature_2m_max[i])}¬∞/${Math.round(data.daily.temperature_2m_min[i])}¬∞</span>`;
            forecastEl.appendChild(dayDiv);
          });
        }
        updateFullscreenWeatherDisplay();
      };
      async function initializeWeather() {
        await determineUserCountry();
        loadWeatherSettings();
        loadGeneralSettings();
        const settingsLoaded = localStorage.getItem(getStorageKey('weatherWidgetSettings'));
        if (!settingsLoaded && navigator.geolocation) {
             // Using the multi-layered location finding immediately
          const useCurrentBtn = document.getElementById('overviewUseCurrentLocationBtn'); // a dummy element to trigger the click logic
          useCurrentBtn.click(); // This will trigger the robust location finding logic
        } else { await fetchWeather(); }
      }
      if (settingsBtn) settingsBtn.addEventListener('click', () => {
        const modal = document.getElementById('overviewSettingsModal');
        modal.classList.add('modal-open');
        populateAllCountdownDropdowns();
        
        // General settings
        const titleWrapper = document.getElementById('title-display-select-wrapper');
        const savedTitleDisplay = generalSettings.titleDisplay || 'none';
        const titleOption = titleWrapper.querySelector(`.custom-option[data-value="${savedTitleDisplay}"]`);
        if(titleOption) {
          titleWrapper.querySelector('.selected')?.classList.remove('selected');
          titleOption.classList.add('selected');
          titleWrapper.querySelector('.custom-select-trigger span').textContent = titleOption.textContent;
        }
        initializeCustomSelect(titleWrapper, (value) => { generalSettings.titleDisplay = value; saveGeneralSettings(); });
        document.getElementById('fullscreenWeatherToggle').checked = weatherSettings.showWeatherInFullscreen;
        
        // Weather settings
        document.getElementById('overviewLocationInput').value = weatherSettings.location.label;
        document.getElementById('overviewUnitToggle').checked = weatherSettings.units === 'metric';
        document.querySelector(`input[name="dataSource"][value="${weatherSettings.dataSource}"]`).checked = true;
        window.updateNWSAvailability();
      });
      if (refreshBtn) refreshBtn.addEventListener('click', fetchWeather);
      initializeWeather(); setInterval(fetchWeather, 30 * 60 * 1000);
    }
  },
  {
    templateId: 'stopwatch_widget', title: 'Stopwatch', icon: '‚è±Ô∏è', type: 'small',
    onMount: (cardElement) => {
      const STORAGE_KEY = getStorageKey('stopwatchState_v4');
      const display = cardElement.querySelector('.stopwatch-display');
      const startBtn = cardElement.querySelector('button[data-action="start"]');
      const pauseBtn = cardElement.querySelector('button[data-action="pause"]');
      const resetBtn = cardElement.querySelector('button[data-action="reset"]');
      let state = { startTime: null, elapsedTime: 0, isRunning: false };
      let intervalId = null;
      function saveState() { const dataToSave = { elapsedTime: state.elapsedTime, isRunning: state.isRunning, startTime: state.isRunning ? state.startTime : null }; localStorage.setItem(STORAGE_KEY, JSON.stringify(dataToSave)); }
      function formatTime(ms) { const totalSeconds = Math.floor(ms / 1000); const centiseconds = Math.floor((ms % 1000) / 10).toString().padStart(2, '0'); const hours = Math.floor(totalSeconds / 3600); const minutes = Math.floor((totalSeconds % 3600) / 60); const seconds = totalSeconds % 60; return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}.${centiseconds}`; }
      function updateDisplay() { const totalElapsed = state.elapsedTime + (state.isRunning ? (Date.now() - state.startTime) : 0); display.textContent = formatTime(totalElapsed); }
      function start() { if (state.isRunning) return; state.isRunning = true; state.startTime = Date.now(); startBtn.style.display = 'none'; pauseBtn.style.display = 'inline-block'; intervalId = setInterval(updateDisplay, 50); saveState(); }
      function pause() { if (!state.isRunning) return; clearInterval(intervalId); state.elapsedTime += Date.now() - state.startTime; state.isRunning = false; startBtn.style.display = 'inline-block'; pauseBtn.style.display = 'none'; saveState(); }
      function reset() { clearInterval(intervalId); state = { startTime: null, elapsedTime: 0, isRunning: false }; localStorage.removeItem(STORAGE_KEY); updateDisplay(); startBtn.style.display = 'inline-block'; pauseBtn.style.display = 'none'; }
      function loadState() { const saved = JSON.parse(localStorage.getItem(STORAGE_KEY)); if (!saved) return; state.elapsedTime = saved.elapsedTime || 0; if (saved.isRunning && saved.startTime) { state.elapsedTime += Date.now() - saved.startTime; start(); } else { updateDisplay(); } }
      startBtn.addEventListener('click', start); pauseBtn.addEventListener('click', pause); resetBtn.addEventListener('click', reset);
      loadState();
    }
  },
  {
    templateId: 'timer_widget', title: 'Timer', icon: '‚åõ', type: 'small',
    onMount: (cardElement) => {
      const STORAGE_KEY = getStorageKey('timerState_v4');
      const inputs = ['w', 'd', 'h', 'm', 's'].map(id => cardElement.querySelector(`#timer-${id}`));
      const display = cardElement.querySelector('.timer-display-value');
      const inputsContainer = cardElement.querySelector('.timer-inputs');
      const startBtn = cardElement.querySelector('button[data-action="start"]');
      const pauseBtn = cardElement.querySelector('button[data-action="pause"]');
      const resetBtn = cardElement.querySelector('button[data-action="reset"]');
      let state = { targetTime: null, remainingTime: 0, isRunning: false };
      let intervalId = null;
      function formatTime(ms) { if (ms < 0) ms = 0; const s = Math.round(ms / 1000); const w = Math.floor(s / 604800); const d = Math.floor((s % 604800) / 86400); const h = Math.floor((s % 86400) / 3600); const m = Math.floor((s % 3600) / 60); const secs = s % 60; const p = (n) => String(n).padStart(2,'0'); if(w > 0) return `${w}:${p(d)}:${p(h)}:${p(m)}:${p(secs)}`; if(d > 0) return `${d}:${p(h)}:${p(m)}:${p(secs)}`; return `${p(h)}:${p(m)}:${p(secs)}`; }
      function updateDisplay() { const remaining = state.isRunning ? state.targetTime - Date.now() : state.remainingTime; display.textContent = formatTime(remaining); if (state.isRunning && remaining <= 0) finish(); }
      function updateFromInputs() { if (state.isRunning) return; const [w, d, h, m, s] = inputs.map(input => parseInt(input.value) || 0); state.remainingTime = (w * 604800 + d * 86400 + h * 3600 + m * 60 + s) * 1000; updateDisplay(); }
      function toggleUI(isRunning) { inputsContainer.classList.toggle('hidden', isRunning); startBtn.style.display = isRunning ? 'none' : 'inline-block'; pauseBtn.style.display = isRunning ? 'inline-block' : 'none'; }
      function start() { if (state.isRunning) return; if (state.remainingTime <= 0) { showNotification("Please set a timer duration.", "info"); return; } state.isRunning = true; state.targetTime = Date.now() + state.remainingTime; intervalId = setInterval(updateDisplay, 100); toggleUI(true); localStorage.setItem(STORAGE_KEY, JSON.stringify({ targetTime: state.targetTime })); }
      function pause() { if (!state.isRunning) return; clearInterval(intervalId); state.remainingTime = state.targetTime - Date.now(); state.isRunning = false; toggleUI(false); localStorage.setItem(STORAGE_KEY, JSON.stringify({ remainingTime: state.remainingTime })); }
      function reset() { clearInterval(intervalId); state.isRunning = false; toggleUI(false); inputs.forEach(input => input.value = '0'); updateFromInputs(); localStorage.removeItem(STORAGE_KEY); }
      function finish() { showNotification('Timer Finished!', 'success'); try { new Audio('https://interactive-examples.mdn.mozilla.net/media/cc0-audio/bell-ringing-01.mp3').play(); } catch(e) {} reset(); }
      function loadState() { const saved = JSON.parse(localStorage.getItem(STORAGE_KEY)); if (!saved) { updateFromInputs(); return; }; if (saved.targetTime) { state.remainingTime = saved.targetTime - Date.now(); if (state.remainingTime > 0) start(); else reset(); } else if (saved.remainingTime) { state.remainingTime = saved.remainingTime; updateDisplay(); } }
      inputs.forEach(input => input.addEventListener('input', updateFromInputs));
      startBtn.addEventListener('click', start); pauseBtn.addEventListener('click', pause); resetBtn.addEventListener('click', reset);
      loadState();
    }
  },
  {
    templateId: 'quick_actions_widget', title: 'Shortcuts', icon: '‚ö°', type: 'small',
    onMount: (cardElement) => {
      const settingsBtn = cardElement.querySelector('.quick-actions-settings-btn');
      const contentContainer = cardElement.querySelector('.quick-actions-list');
      const renderAndAttachListeners = (actions) => {
        contentContainer.innerHTML = actions.map(action => `<button data-type="${action.type}" data-value="${action.value}"><span class="icon">${action.icon}</span><span class="text">${action.text}</span><span class="arrow">‚Üí</span></button>`).join('');
        contentContainer.querySelectorAll('button').forEach(btn => {
          btn.addEventListener('click', () => { const { type, value } = btn.dataset; if (type === 'url') { window.open(value, '_blank'); } else if (type === 'page') { const page = pageSuggestions.find(p => p.url === value); if (page && page.action) { page.action(); } else { window.location.href = value; } } });
        });
      };
      const updateUI = () => { const saved = localStorage.getItem(getStorageKey('quickActions_v1')); currentQuickActions = saved ? JSON.parse(saved) : [...defaultQuickActions]; renderAndAttachListeners(currentQuickActions); };
      window.updateQuickActionsWidget = updateUI;
      updateUI();
      if (settingsBtn) { settingsBtn.addEventListener('click', () => { populateShortcutSettingsForm(); document.getElementById('shortcutSettingsModal').classList.add('modal-open'); }); }
    }
  }
];

function getContentGenerator(templateId) {
    switch (templateId) {
        case 'time_weather_super_widget': return () => `
            <div class="super-widget-container">
                <div class="super-widget-clock-section">
                    <div class="clock-display" id="clockTime">00:00:00</div>
                    <div class="date-display" id="clockDate"></div>
                    <div class="additional-time-info">
                        <span id="clockDayOfYear">Day: ---</span> | <span id="clockWeekNum">Week: --</span>
                    </div>
                    <div class="dashboard-countdown-section" style="display: none;">
                        <h4 class="dashboard-countdown-display-name"></h4>
                        <div class="dashboard-countdown-display-timer"></div>
                    </div>
                </div>
                <div class="super-widget-weather-section">
                    <div class="weather-large-content">
                        <div class="current-weather-layout">
                            <span class="weather-icon-large"></span> <div class="current-weather-main-info"> <span class="temp-large"></span> <span class="condition-large"></span> </div>
                            <div class="current-weather-details-aside"> <p>Feels like: <span class="feels-like-value"></span></p> <p>Humidity: <span class="humidity-value"></span></p> <p>Wind: <span class="wind-value"></span></p> <p>Location: <span class="location-large"></span></p> </div>
                        </div> <div class="forecast-large"></div>
                    </div>
                </div>
            </div>`;
        case 'stopwatch_widget': return () => `<div class="stopwatch-display">00:00:00.00</div><div class="controls-flex"><button data-action="start">Start</button><button data-action="pause" style="display:none;">Pause</button><button data-action="reset">Reset</button></div>`;
        case 'timer_widget': return () => `<div class="timer-display-value">00:00:00</div><div class="timer-inputs"><input type="number" id="timer-w" placeholder="W" min="0" max="1" value="0">:<input type="number" id="timer-d" placeholder="D" min="0" max="6" value="0">:<input type="number" id="timer-h" placeholder="HH" min="0" max="23" value="0">:<input type="number" id="timer-m" placeholder="MM" min="0" max="59" value="0">:<input type="number" id="timer-s" placeholder="SS" min="0" max="59" value="0"></div><div class="controls-flex"><button data-action="start">Start</button><button data-action="pause" style="display:none;">Pause</button><button data-action="reset">Reset</button></div>`;
        case 'quick_actions_widget': return () => `<div class="quick-actions-list"></div>`;
        default: return () => '';
    }
}

function createCardDOMElement(t){const c=document.createElement('div');c.className='dashboard-card';c.dataset.templateId=t.templateId;c.dataset.cardType=t.type||'full';c.innerHTML=`<div class="card-header"><div class="card-icon">${t.icon}</div><h4 class="card-title">${t.title}</h4><div class="card-header-buttons"></div></div><div class="card-content-inner">${getContentGenerator(t.templateId)()}</div>`;const b=c.querySelector('.card-header-buttons');if(t.templateId==='time_weather_super_widget'){b.innerHTML=`<button class="weather-action-btn overview-settings-btn" title="Overview Settings"><img src="../images/gear-dark.png"></button><button class="weather-action-btn weather-refresh-btn" title="Refresh Weather"><img src="../images/refresh-dark.png"></button><button class="weather-action-btn clock-fullscreen-btn" title="Fullscreen Clock"><img src="../images/zoom-in-dark.png"></button>`}else if(t.templateId==='quick_actions_widget'){b.innerHTML=`<button class="weather-action-btn quick-actions-settings-btn" title="Edit Shortcuts"><img src="../images/gear-dark.png"></button>`}if(t.onMount){setTimeout(()=>{try{t.onMount(c)}catch(e){console.error(`Error onMount for ${t.templateId}:`,e);c.querySelector('.card-content-inner').innerHTML=`<p style="color:red;">Failed to load widget.</p>`}},0)}return c}
function renderDashboardLayout(){const l=getDashboardLayout();dashboardGrid.innerHTML='';l.forEach(id=>{const t=availableCardTemplates.find(t=>t.templateId===id);if(t)dashboardGrid.appendChild(createCardDOMElement(t))});dashboardGrid.querySelectorAll('.dashboard-card').forEach((c,i)=>{c.style.animation='none';c.offsetHeight;c.style.animation=`fadeIn 0.4s ease-out ${i*0.05}s forwards`})}
function getDashboardLayout(){const s=localStorage.getItem(dashboardLayoutStorageKey);if(s){try{const p=JSON.parse(s);if(Array.isArray(p)&&p.length>0)return p}catch(e){}}return[...defaultDashboardLayout]}
function showNotification(message,type='info',duration=3000){const n=document.createElement('div');n.className=`notification ${type}`;n.textContent=message;Object.assign(n.style,{position:'fixed',bottom:'20px',right:'20px',padding:'12px 20px',borderRadius:'8px',color:'white',fontWeight:'600',zIndex:'10000',transform:'translateY(150%)',transition:'transform 0.4s ease-in-out',background:type==='success'?'linear-gradient(135deg,#28a745,#20c997)':type==='error'?'linear-gradient(135deg,#dc3545,#e83e8c)':'linear-gradient(135deg,#6720bd,#8a2be2)'});document.body.appendChild(n);setTimeout(()=>{n.style.transform='translateY(0)'},100);setTimeout(()=>{n.style.transform='translateY(150%)';setTimeout(()=>{if(document.body.contains(n))document.body.removeChild(n)},400)},duration)}

// --- CUSTOM SELECT DROPDOWN LOGIC ---
function initializeCustomSelect(wrapper, onChangeCallback) {
    if (wrapper.dataset.customSelectInitialized) return;
    const select = wrapper.querySelector('.custom-select');
    const trigger = select.querySelector('.custom-select-trigger');
    const optionsContainer = select.querySelector('.custom-options');

    const handleTriggerClick = (e) => { e.stopPropagation(); select.classList.toggle('open'); };
    const handleOptionClick = (e) => {
        const option = e.target.closest('.custom-option');
        if (option && !option.classList.contains('disabled')) { // Prevent clicking disabled options
            const value = option.dataset.value;
            const text = option.textContent;
            if (optionsContainer.querySelector('.selected')) {
                optionsContainer.querySelector('.selected').classList.remove('selected');
            }
            option.classList.add('selected');
            trigger.querySelector('span').textContent = text;
            select.classList.remove('open');
            if (onChangeCallback) onChangeCallback(value);
        }
    };
    
    trigger.addEventListener('click', handleTriggerClick);
    optionsContainer.addEventListener('click', handleOptionClick);
    wrapper.dataset.customSelectInitialized = true;
}
document.addEventListener('click', () => { document.querySelectorAll('.custom-select.open').forEach(select => select.classList.remove('open')); });

// --- SHORTCUTS SETTINGS LOGIC ---
function populateShortcutSettingsForm() {
    const form = document.getElementById('shortcutSettingsForm');
    form.innerHTML = '';
    currentQuickActions.forEach((action, index) => {
        const group = document.createElement('div');
        group.className = 'shortcut-editor-group';
        group.innerHTML = `<h4>Shortcut ${index + 1}</h4><div class="shortcut-input-row"><label>Icon</label><input type="text" class="shortcut-emoji-input" value="${action.icon}" maxlength="2"><label>Name</label><input type="text" class="shortcut-name-input" value="${action.text}"></div><div class="shortcut-input-row"><label>Action Type</label><select class="shortcut-action-type-select"><option value="url" ${action.type === 'url' ? 'selected' : ''}>Go to URL</option><option value="page" ${action.type === 'page' ? 'selected' : ''}>Go to Page</option></select></div><div class="shortcut-input-row action-target-wrapper"><label class="url-label ${action.type !== 'url' ? 'hidden' : ''}">URL</label><input type="url" class="shortcut-url-input ${action.type !== 'url' ? 'hidden' : ''}" value="${action.type === 'url' ? action.value : 'https://'}" placeholder="https://example.com"><label class="page-label ${action.type !== 'page' ? 'hidden' : ''}">Page</label><select class="shortcut-page-select ${action.type !== 'page' ? 'hidden' : ''}">${pageSuggestions.map(p => `<option value="${p.url}" ${action.type === 'page' && action.value === p.url ? 'selected' : ''}>${p.name}</option>`).join('')}</select></div>`;
        form.appendChild(group);
    });
    form.querySelectorAll('.shortcut-action-type-select').forEach(select => {
        select.addEventListener('change', (e) => {
            const wrapper = e.target.closest('.shortcut-editor-group').querySelector('.action-target-wrapper');
            const isUrl = e.target.value === 'url';
            wrapper.querySelector('.url-label').classList.toggle('hidden', !isUrl); wrapper.querySelector('.shortcut-url-input').classList.toggle('hidden', !isUrl); wrapper.querySelector('.page-label').classList.toggle('hidden', isUrl); wrapper.querySelector('.shortcut-page-select').classList.toggle('hidden', isUrl);
        });
    });
}
function saveShortcutSettings() {
    const newActions = [];
    document.getElementById('shortcutSettingsForm').querySelectorAll('.shortcut-editor-group').forEach(group => {
        const type = group.querySelector('.shortcut-action-type-select').value;
        newActions.push({ icon: group.querySelector('.shortcut-emoji-input').value, text: group.querySelector('.shortcut-name-input').value, type: type, value: type === 'url' ? group.querySelector('.shortcut-url-input').value : group.querySelector('.shortcut-page-select').value });
    });
    localStorage.setItem(getStorageKey('quickActions_v1'), JSON.stringify(newActions));
    currentQuickActions = newActions;
    window.updateQuickActionsWidget();
    document.getElementById('shortcutSettingsModal').classList.remove('modal-open');
    showNotification("Shortcuts saved!", "success");
}
function resetShortcutSettings() {
    localStorage.removeItem(getStorageKey('quickActions_v1'));
    currentQuickActions = [...defaultQuickActions];
    populateShortcutSettingsForm();
    showNotification("Shortcuts reset to default.", "info");
}

// --- LOCATION HELPER FUNCTIONS ---
const getLocation = (options) => new Promise((resolve, reject) => navigator.geolocation.getCurrentPosition(resolve, reject, options));

const getLocationByIP = async () => {
    try {
        const r = await fetch('https://ipapi.co/json/');
        if (!r.ok) throw new Error('IP API response not OK');
        const d = await r.json();
        if (d.error) throw new Error(d.reason);
        if (!d.latitude || !d.longitude) throw new Error('IP location data incomplete');
        return { coords: { latitude: d.latitude, longitude: d.longitude } };
    } catch (e) {
        console.error("IP-based geolocation failed:", e);
        throw e;
    }
};

function getShortLocationLabel(address, fullDisplayName) {
    if (!address) return fullDisplayName;
    const city = address.city || address.town || address.village || address.hamlet;
    if (address.road && city) { return `${address.road}, ${city}`; }
    if (city && address.state) { return `${city}, ${address.state}`; }
    if (city && address.country) { return `${city}, ${address.country}`; }
    if (city) { return city; }
    return fullDisplayName;
}

async function fetchCityName(lat, lon) {
    const nominatimUrl = `https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${lat}&lon=${lon}&zoom=18&addressdetails=1`;
    const fallbackLabel = `Lat: ${parseFloat(lat).toFixed(2)}, Lon: ${parseFloat(lon).toFixed(2)}`;
    try {
        const response = await fetch(nominatimUrl);
        if (!response.ok) { console.warn(`Nominatim API error: ${response.status}`); return { label: fallbackLabel, country_code: 'us' }; }
        const data = await response.json();
        if (data && data.address) { const label = getShortLocationLabel(data.address, data.display_name); return { label, country_code: data.address.country_code || 'us' }; }
        return { label: fallbackLabel, country_code: 'us' };
    } catch (error) { console.error("Error fetching city name:", error); return { label: fallbackLabel, country_code: 'us' }; }
}

// --- INITIALIZATION ---
document.addEventListener('DOMContentLoaded', () => {
    // --- START: Legal Disclaimer Logic ---
    const disclaimerOverlay = document.getElementById('legal-disclaimer-overlay');
    const agreeBtn = document.getElementById('agree-btn');
    const disagreeBtn = document.getElementById('disagree-btn');
    // We use a versioned key so you can force re-agreement if terms change
    const agreementKey = 'hasAgreedToTerms_v1_Sept2025';

    if (!localStorage.getItem(agreementKey)) {
        disclaimerOverlay.classList.add('visible');
    }

    agreeBtn.addEventListener('click', () => {
        localStorage.setItem(agreementKey, 'true');
        disclaimerOverlay.classList.remove('visible');
    });

    disagreeBtn.addEventListener('click', () => {
        window.location.href = '../index.html';
    });
    // --- END: Legal Disclaimer Logic ---

    firebase.auth().onAuthStateChanged(user => { 
        if (!user) {
            location.href = '../login.html';
        } else {
            originalTitle = document.title;
            loadGeneralSettings();
            renderDashboardLayout(); 
            if (titleUpdateInterval) clearInterval(titleUpdateInterval);
            titleUpdateInterval = setInterval(updateBrowserTabTitle, 100);
        }
    });
    document.getElementById('logoutBtn').addEventListener('click', () => firebase.auth().signOut());
    document.getElementById('signOutLink').addEventListener('click', (e) => { e.preventDefault(); firebase.auth().signOut(); });
    document.getElementById('toggleSidebar').addEventListener('click', () => document.getElementById('sidebar').classList.toggle('collapsed'));
    
    // Modal Handling
    const settingsModal = document.getElementById('overviewSettingsModal');
    document.querySelectorAll('.modal').forEach(modal => {
        const closeBtn = modal.querySelector('.modal-close-btn');
        const isSettingsModal = modal.id === 'overviewSettingsModal';
        const closeModal = () => {
            modal.classList.remove('modal-open');
            if (isSettingsModal) fetchWeather();
            if (modal.id === 'customGradientModal') { // ADDED: Restart inactivity timer on close
                resetInactivityTimer();
            }
        };
        if(closeBtn) closeBtn.addEventListener('click', closeModal);
        modal.addEventListener('click', (e) => { if(e.target === modal) closeModal(); });
    });

    // === UPDATED: Settings Modal Sliding Tab Logic ===
    const tabButtons = settingsModal.querySelectorAll('.tab-button');
    const tabPanelContainer = settingsModal.querySelector('.tab-panels-container');
    settingsModal.querySelector('.settings-tabs').addEventListener('click', e => {
        const clickedButton = e.target.closest('.tab-button');
        if (clickedButton) {
            const tabIndex = Array.from(tabButtons).indexOf(clickedButton);
            tabButtons.forEach(btn => btn.classList.remove('active'));
            clickedButton.classList.add('active');
            if (tabPanelContainer) {
                tabPanelContainer.style.transform = `translateX(-${tabIndex * 100}%)`;
            }
        }
    });

    // Countdown Creation Modal
    const dateTimePicker = flatpickr("#newCountdownDateTime", { enableTime: true, dateFormat: "Y-m-d H:i", minDate: "today" });
    document.getElementById('saveNewCountdownBtn').addEventListener('click', () => { const name = document.getElementById('newCountdownName').value.trim(); const dateTime = dateTimePicker.selectedDates[0]; if (!name || !dateTime) { showNotification("Please provide a name and a future date.", "error"); return; } const newCountdown = { id: `cd_${Date.now()}`, name, targetTimestamp: dateTime.toISOString() }; const key = getStorageKey('countdowns'); const countdowns = JSON.parse(localStorage.getItem(key) || '[]'); countdowns.push(newCountdown); localStorage.setItem(key, JSON.stringify(countdowns)); showNotification("Countdown saved!", "success"); document.getElementById('newCountdownModal').classList.remove('modal-open'); document.getElementById('newCountdownName').value = ''; dateTimePicker.clear(); populateAllCountdownDropdowns(); if (window.updateDashboardCountdownDisplay) window.updateDashboardCountdownDisplay(); });
    
    // Shortcut Settings
    document.getElementById('saveShortcutsBtn').addEventListener('click', saveShortcutSettings);
    document.getElementById('resetShortcutsBtn').addEventListener('click', resetShortcutSettings);

    // Weather Location Settings
    const wLocInput = document.getElementById('overviewLocationInput'), wLocSuggest = document.getElementById('overviewLocationSuggestions'), useCurrentBtn = document.getElementById('overviewUseCurrentLocationBtn');
    
    wLocInput.addEventListener('input', (e) => {
        const q = e.target.value;
        if (q.length < 3) {
            wLocSuggest.style.display = 'none';
            return;
        }
        fetchLocationSuggestions(q);
    });

    useCurrentBtn.addEventListener('click', async () => {
        useCurrentBtn.disabled = true;
        useCurrentBtn.textContent = 'Locating...';
        let locationFound = false;

        const processPosition = async (position) => {
            const { latitude, longitude } = position.coords;
            userCoords = { lat: latitude, lon: longitude };
            const { label } = await fetchCityName(latitude, longitude);
            weatherSettings.location = { label, latitude, longitude };
            wLocInput.value = label;
            saveWeatherSettings();
            showNotification(`Location updated to ${label}`, 'success');
        };

        // Layer 1: High Accuracy Geolocation
        if (navigator.geolocation) {
            try {
                const position = await getLocation({ enableHighAccuracy: true, timeout: 8000 });
                await processPosition(position);
                locationFound = true;
            } catch (highAccError) {
                console.warn(`High accuracy geolocation failed: ${highAccError.message}. Trying low accuracy.`);
                // Layer 2: Low Accuracy Geolocation
                try {
                    const position = await getLocation({ enableHighAccuracy: false, timeout: 10000 });
                    await processPosition(position);
                    locationFound = true;
                } catch (lowAccError) {
                    console.warn(`Low accuracy geolocation failed: ${lowAccError.message}. Trying IP-based location.`);
                }
            }
        }

        // Layer 3: IP-Based Geolocation Fallback
        if (!locationFound) {
            try {
                const position = await getLocationByIP();
                await processPosition(position);
                locationFound = true;
            } catch (ipError) {
                console.error(`IP-based location failed: ${ipError.message}`);
                showNotification("Could not automatically determine location. Please search manually.", "error");
            }
        }
        
        useCurrentBtn.disabled = false;
        useCurrentBtn.textContent = 'üìç Use My Current Location';

        if (locationFound) {
            settingsModal.classList.remove('modal-open');
            fetchWeather();
        }
    });

    async function fetchLocationSuggestions(query) {
        let url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&addressdetails=1&limit=5`;
        try {
            const r = await fetch(url); const d = await r.json(); wLocSuggest.innerHTML = '';
            if (d.length > 0) {
                wLocSuggest.style.display = 'block';
                d.forEach(p => {
                    const shortLabel = getShortLocationLabel(p.address, p.display_name); const li = document.createElement('li'); li.textContent = shortLabel;
                    li.addEventListener('click', () => {
                        weatherSettings.location = { label: shortLabel, latitude: parseFloat(p.lat), longitude: parseFloat(p.lon) }; wLocInput.value = shortLabel; wLocSuggest.style.display = 'none'; saveWeatherSettings();
                        settingsModal.classList.remove('modal-open'); fetchWeather();
                    });
                    wLocSuggest.appendChild(li);
                });
            } else { wLocSuggest.style.display = 'none'; }
        } catch (e) { console.error("Failed to fetch location suggestions:", e); }
    }

    // Other Settings Listeners
    document.getElementById('overviewUnitToggle').addEventListener('change', (e) => { weatherSettings.units = e.target.checked ? 'metric' : 'imperial'; saveWeatherSettings(); });
    document.querySelectorAll('input[name="dataSource"]').forEach(r => {r.addEventListener('change', (e) => { weatherSettings.dataSource = e.target.value; saveWeatherSettings(); window.updateNWSAvailability(); })});
    window.updateNWSAvailability = function(isUS = userCountry === 'US') { const nR = document.getElementById('sourceNWS'); const nN = document.getElementById('nwsApiNote'); if (isUS) { nR.disabled = false; nN.style.display = 'none'; } else { if (weatherSettings.dataSource === 'nws') { weatherSettings.dataSource = 'open-meteo'; saveWeatherSettings(); document.getElementById('sourceOpenMeteo').checked = true; } nR.disabled = true; nN.style.display = 'block'; }};
    const fsWeatherToggle = document.getElementById('fullscreenWeatherToggle'); fsWeatherToggle.addEventListener('change', () => { weatherSettings.showWeatherInFullscreen = fsWeatherToggle.checked; saveWeatherSettings(); updateFullscreenWeatherDisplay(); });
    
    // Fullscreen Color Palette
    const colorToggle = document.getElementById('clock-fs-color-toggle'), colorPalette = document.getElementById('clock-fs-color-palette'), colorPickerInput = document.getElementById('color-picker-input');
    colorToggle.addEventListener('click', (e) => { e.stopPropagation(); colorPalette.classList.toggle('visible'); });
    document.addEventListener('click', (e) => { if (!colorPalette.contains(e.target) && !colorToggle.contains(e.target)) { colorPalette.classList.remove('visible'); } });
    colorPalette.addEventListener('click', (e) => {
        if(e.target.classList.contains('color-swatch') && !e.target.classList.contains('color-swatch-custom') && !e.target.classList.contains('color-swatch-custom-gradient')) {
            const color = e.target.dataset.color;
            clockFsOverlay.style.background = color;
            localStorage.setItem(getStorageKey('clockFsColor'), color);
        }
    });
    document.querySelector('.color-swatch-custom').addEventListener('click', () => colorPickerInput.click());
    colorPickerInput.addEventListener('input', (e) => {
        const color = e.target.value;
        clockFsOverlay.style.background = color;
        localStorage.setItem(getStorageKey('clockFsColor'), color);
    });

    // --- Custom Gradient Modal Logic (NEW) ---
    const gradientModal = document.getElementById('customGradientModal');
    const customGradientSwatch = document.querySelector('.color-swatch-custom-gradient');
    const gradientTypeRadios = document.querySelectorAll('input[name="gradient-type"]');
    const colorPickersWrapper = document.querySelector('.color-pickers-wrapper');

    if (customGradientSwatch) {
        customGradientSwatch.addEventListener('click', () => {
            gradientModal.classList.add('modal-open');
            clearTimeout(inactivityTimer); // Pause inactivity timer
        });
    }

    function updateGradientBackground() {
        const selectedType = document.querySelector('input[name="gradient-type"]:checked').value;
        const pickerGroup = colorPickersWrapper.querySelector(`.color-picker-group[data-type="${selectedType}"]`);
        const colors = Array.from(pickerGroup.querySelectorAll('input[type="color"]')).map(input => input.value);
        let gradientString = '';

        switch (selectedType) {
            case 'linear-2':
                gradientString = `linear-gradient(to right, ${colors[0]}, ${colors[1]})`;
                break;
            case 'linear-3':
                gradientString = `linear-gradient(to right, ${colors[0]}, ${colors[1]}, ${colors[2]})`;
                break;
            case 'radial-2':
                gradientString = `radial-gradient(circle, ${colors[0]}, ${colors[1]})`;
                break;
            case 'conic':
                gradientString = `conic-gradient(from 0deg, ${colors.join(', ')}, ${colors[0]})`;
                break;
        }

        if (gradientString) {
            clockFsOverlay.style.background = gradientString;
            localStorage.setItem(getStorageKey('clockFsColor'), gradientString);
        }
    }

    gradientTypeRadios.forEach(radio => {
        radio.addEventListener('change', (e) => {
            document.querySelectorAll('.color-picker-group').forEach(group => group.style.display = 'none');
            const targetGroup = colorPickersWrapper.querySelector(`.color-picker-group[data-type="${e.target.value}"]`);
            if (targetGroup) {
                targetGroup.style.display = 'flex';
                updateGradientBackground(); // Update preview when type changes
            }
        });
    });
    
    colorPickersWrapper.addEventListener('input', (e) => {
        if (e.target.type === 'color') {
            updateGradientBackground();
        }
    });
});
  </script>
</body>
</html>
